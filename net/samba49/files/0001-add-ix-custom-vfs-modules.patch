diff --git a/source3/modules/vfs_ixnas.c b/source3/modules/vfs_ixnas.c
new file mode 100644
index 0000000..e049604
--- /dev/null
+++ b/source3/modules/vfs_ixnas.c
@@ -0,0 +1,782 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *  A dumping ground for FreeBSD-specific VFS functions. For testing case
+ *  of reducing number enabled VFS modules to bare minimum by creating
+ *  single large VFS module.
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "MacExtensions.h"
+#include "smbd/smbd.h"
+#include "libcli/security/security.h"
+#include "nfs4_acls.h"
+#include "system/filesys.h"
+
+#if HAVE_FREEBSD_SUNACL_H
+#include "sunacl.h"
+#endif
+
+#if HAVE_LIBZFS
+#include "lib/util/tevent_ntstatus.h"
+#include "modules/zfs_disk_free.h"
+#endif
+
+#define ZFSACL_MODULE_NAME "ixnas"
+#undef DBGC_CLASS
+#define DBGC_CLASS DBGC_VFS
+
+struct ixnas_config_data {
+	struct smbacl4_vfs_params nfs4_params;
+	bool posix_rename;
+	bool dosmode_enabled;
+	bool dosmode_remote_storage;
+	bool zfs_acl_enabled;
+	bool zfs_acl_mapdaclprotected;
+	bool zfs_acl_denymissingspecial;
+	bool zfs_space_enabled;
+};
+
+static uint32_t ixnas_fs_capabilities(struct vfs_handle_struct *handle,
+				enum timestamp_set_resolution *p_ts_res)
+{
+	uint32_t fs_capabilities = SMB_VFS_NEXT_FS_CAPABILITIES(handle, p_ts_res);
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (config->dosmode_remote_storage) {
+		fs_capabilities |= FILE_SUPPORTS_REMOTE_STORAGE;
+	}
+	
+	return fs_capabilities;
+}
+
+/********************************************************************
+ Fuctions to store DOS attributes as File Flags.
+********************************************************************/
+static uint32_t fileflags_to_dosmode(uint32_t fileflags)
+{
+	uint32_t dosmode = 0;
+	if (fileflags & UF_READONLY){
+		dosmode |= FILE_ATTRIBUTE_READONLY;
+	}
+	if (fileflags & UF_ARCHIVE){
+		dosmode |= FILE_ATTRIBUTE_ARCHIVE;
+	}
+	if (fileflags & UF_SYSTEM){
+		dosmode |= FILE_ATTRIBUTE_SYSTEM;
+	}
+	if (fileflags & UF_HIDDEN){
+		dosmode |= FILE_ATTRIBUTE_HIDDEN;
+	}
+	if (fileflags & UF_SPARSE){
+		dosmode |= FILE_ATTRIBUTE_SPARSE;
+	}
+	if (fileflags & UF_OFFLINE){
+		dosmode |= FILE_ATTRIBUTE_OFFLINE;
+	}
+
+	return dosmode;
+}
+
+static uint32_t dosmode_to_fileflags(uint32_t dosmode)
+{
+	uint32_t fileflags = 0;
+	if (dosmode & FILE_ATTRIBUTE_ARCHIVE) {
+		fileflags |= UF_ARCHIVE;
+	}
+	if (dosmode & FILE_ATTRIBUTE_HIDDEN) {
+		fileflags |= UF_HIDDEN;
+	}
+	if (dosmode & FILE_ATTRIBUTE_OFFLINE) {
+		fileflags |= UF_OFFLINE;
+	}
+	if (dosmode & FILE_ATTRIBUTE_READONLY) {
+		fileflags |= UF_READONLY;
+	}
+	if (dosmode & FILE_ATTRIBUTE_SPARSE) {
+		fileflags |= UF_SPARSE;
+	}
+	if (dosmode & FILE_ATTRIBUTE_SYSTEM) {
+		fileflags |= UF_SYSTEM;
+}
+
+return fileflags;
+}
+
+static NTSTATUS set_dos_attributes_common(struct vfs_handle_struct *handle,
+					 const struct smb_filename *smb_fname,
+					 uint32_t dosmode)
+{
+	int ret;
+	bool set_dosmode_ok = false;
+	NTSTATUS status = NT_STATUS_OK;
+	uint32_t fileflags = dosmode_to_fileflags(dosmode);
+
+	DEBUG(10,("ixnas:set_dos_attributes: set attribute 0x%x, on file %s\n",
+	dosmode, smb_fname->base_name));
+	/*
+	* Optimization. This is most likely set by file owner. First try without
+	* performing additional permissions checks and using become_root().
+	*/
+
+	ret = SMB_VFS_CHFLAGS(handle->conn, smb_fname, fileflags);
+
+	if (ret ==-1 && errno == EPERM) {
+	/*
+	* We want DOS semantics, i.e. allow non-owner with write permission to
+	* change the bits on a file.   
+	*/
+
+		if (!CAN_WRITE(handle->conn)) {
+			return NT_STATUS_ACCESS_DENIED;
+		}
+
+		status = smbd_check_access_rights(handle->conn, smb_fname, false,
+						FILE_WRITE_ATTRIBUTES);
+		if (NT_STATUS_IS_OK(status)) {
+			set_dosmode_ok = true;
+		}
+
+		if (!set_dosmode_ok && lp_dos_filemode(SNUM(handle->conn))) {
+			set_dosmode_ok = can_write_to_file(handle->conn, smb_fname);
+		}
+
+		if (!set_dosmode_ok){
+			return NT_STATUS_ACCESS_DENIED;
+		}
+
+		/* becomeroot() because non-owners need to write flags */
+
+		become_root();
+		ret = SMB_VFS_CHFLAGS(handle->conn, smb_fname, fileflags);
+		unbecome_root();
+
+		if (ret == -1) {
+			DBG_WARNING("Setting dosmode failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+			return map_nt_error_from_unix(errno);
+		}
+		return NT_STATUS_OK;
+	}
+
+	if (ret == -1) {
+		DBG_WARNING("Setting dosmode failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		return map_nt_error_from_unix(errno);
+	}
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_get_dos_attributes(struct vfs_handle_struct *handle,
+					 struct smb_filename *smb_fname,
+					 uint32_t *dosmode)
+{
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->dosmode_enabled) {
+		return SMB_VFS_NEXT_GET_DOS_ATTRIBUTES(handle, smb_fname, dosmode);
+	}
+	
+	*dosmode = fileflags_to_dosmode(smb_fname->st.st_ex_flags);
+
+	if (config->dosmode_remote_storage) {
+		*dosmode |= FILE_ATTRIBUTE_OFFLINE;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_fget_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t *dosmode)
+{
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->dosmode_enabled) {
+		return SMB_VFS_NEXT_FGET_DOS_ATTRIBUTES(handle, fsp, dosmode);
+	}
+
+        *dosmode = fileflags_to_dosmode(fsp->fsp_name->st.st_ex_flags);
+
+	if (config->dosmode_remote_storage) {
+		*dosmode |= FILE_ATTRIBUTE_OFFLINE;
+	}
+
+        return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_set_dos_attributes(struct vfs_handle_struct *handle,
+                                           const struct smb_filename *smb_fname,
+                                           uint32_t dosmode)
+{
+	NTSTATUS ret;
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->dosmode_enabled) {
+		return SMB_VFS_NEXT_SET_DOS_ATTRIBUTES(handle, smb_fname, dosmode);
+	}
+
+	ret = set_dos_attributes_common(handle, smb_fname, dosmode);
+                
+        return ret;
+}
+
+static NTSTATUS ixnas_fset_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t dosmode)
+{
+	NTSTATUS ret;
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->dosmode_enabled) {
+		return SMB_VFS_NEXT_FSET_DOS_ATTRIBUTES(handle, fsp, dosmode);
+	}
+	ret = set_dos_attributes_common(handle, fsp->fsp_name, dosmode);
+
+	return ret;
+}
+
+/********************************************************************
+ Correctly calculate free space on ZFS 
+********************************************************************/
+#if HAVE_LIBZFS
+static uint64_t ixnas_disk_free(vfs_handle_struct *handle, const struct smb_filename *smb_fname,
+				uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	uint64_t res;
+	char rp[PATH_MAX] = { 0 };
+
+	if (realpath(smb_fname->base_name, rp) == NULL)
+		return (-1);
+
+	DEBUG(9, ("realpath = %s\n", rp));
+
+	res = smb_zfs_disk_free(rp, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		res = SMB_VFS_NEXT_DISK_FREE(handle, smb_fname, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		return (res);
+
+	DEBUG(9, ("*bsize = %" PRIu64 "\n", *bsize));
+	DEBUG(9, ("*dfree = %" PRIu64 "\n", *dfree));
+	DEBUG(9, ("*dsize = %" PRIu64 "\n", *dsize));
+
+	return (res);
+}
+#endif
+
+/********************************************************************
+ Functions for OSX compatibility. 
+********************************************************************/
+static NTSTATUS ixnas_create_file(vfs_handle_struct *handle,
+				  struct smb_request *req,
+				  uint16_t root_dir_fid,
+				  struct smb_filename *smb_fname,
+				  uint32_t access_mask,
+				  uint32_t share_access,
+				  uint32_t create_disposition,
+				  uint32_t create_options,
+				  uint32_t file_attributes,
+				  uint32_t oplock_request,
+				  struct smb2_lease *lease,
+				  uint64_t allocation_size,
+				  uint32_t private_flags,
+				  struct security_descriptor *sd,
+				  struct ea_list *ea_list,
+				  files_struct **result,
+				  int *pinfo,
+				  const struct smb2_create_blobs *in_context_blobs,
+				  struct smb2_create_blobs *out_context_blobs)
+{
+	NTSTATUS status;
+	struct ixnas_config_data *config = NULL;
+	files_struct *fsp = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	status = SMB_VFS_NEXT_CREATE_FILE(
+		handle, req, root_dir_fid, smb_fname,
+		access_mask, share_access,
+		create_disposition, create_options,
+		file_attributes, oplock_request,
+		lease,
+		allocation_size, private_flags,
+		sd, ea_list, result,
+		pinfo, in_context_blobs, out_context_blobs);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		return status;
+	}
+
+	fsp = *result;
+
+	if (config->posix_rename && fsp->is_directory) {
+		fsp->posix_flags |= FSP_POSIX_FLAGS_RENAME;
+	}
+
+	return status;
+}
+
+/********************************************************************
+ Functions to use ZFS ACLs. 
+********************************************************************/
+/* zfs_get_nt_acl()
+ * read the local file's acls and return it in NT form
+ * using the NFSv4 format conversion
+ */
+static NTSTATUS zfs_get_nt_acl_common(struct connection_struct *conn,
+				      TALLOC_CTX *mem_ctx,
+				      const struct smb_filename *smb_fname,
+				      struct SMB4ACL_T **ppacl,
+				      struct ixnas_config_data *config)
+{
+	int naces, i;
+	ace_t *acebuf;
+	struct SMB4ACL_T *pacl;
+	SMB_STRUCT_STAT sbuf;
+	const SMB_STRUCT_STAT *psbuf = NULL;
+	int ret;
+	bool is_dir;
+
+	if (VALID_STAT(smb_fname->st)) {
+		psbuf = &smb_fname->st;
+	}
+
+	if (psbuf == NULL) {
+		ret = vfs_stat_smb_basename(conn, smb_fname, &sbuf);
+		if (ret != 0) {
+			DBG_INFO("stat [%s]failed: %s\n",
+				 smb_fname_str_dbg(smb_fname), strerror(errno));
+			return map_nt_error_from_unix(errno);
+		}
+		psbuf = &sbuf;
+	}
+	is_dir = S_ISDIR(psbuf->st_ex_mode);
+
+	/* read the number of file aces */
+	if((naces = acl(smb_fname->base_name, ACE_GETACLCNT, 0, NULL)) == -1) {
+		if(errno == ENOSYS) {
+			DEBUG(9, ("acl(ACE_GETACLCNT, %s): Operation is not "
+				  "supported on the filesystem where the file "
+				  "reside\n", smb_fname->base_name));
+		} else {
+			DEBUG(9, ("acl(ACE_GETACLCNT, %s): %s ", smb_fname->base_name,
+					strerror(errno)));
+		}
+		return map_nt_error_from_unix(errno);
+	}
+	/* allocate the field of ZFS aces */
+	mem_ctx = talloc_tos();
+	acebuf = (ace_t *) talloc_size(mem_ctx, sizeof(ace_t)*naces);
+	if(acebuf == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	/* read the aces into the field */
+	if(acl(smb_fname->base_name, ACE_GETACL, naces, acebuf) < 0) {
+		DEBUG(9, ("acl(ACE_GETACL, %s): %s ", smb_fname->base_name,
+				strerror(errno)));
+		return map_nt_error_from_unix(errno);
+	}
+	/* create SMB4ACL data */
+	if((pacl = smb_create_smb4acl(mem_ctx)) == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	for(i=0; i<naces; i++) {
+		SMB_ACE4PROP_T aceprop;
+
+		aceprop.aceType  = (uint32_t) acebuf[i].a_type;
+		aceprop.aceFlags = (uint32_t) acebuf[i].a_flags;
+		aceprop.aceMask  = (uint32_t) acebuf[i].a_access_mask;
+		aceprop.who.id   = (uint32_t) acebuf[i].a_who;
+
+		if (aceprop.aceFlags & ACE_EVERYONE){
+			if (!(acebuf[i].a_access_mask &= ACE_ALL_PERMS)) {
+				continue;
+			}
+		}
+
+		/*
+		 * Windows clients expect SYNC on acls to correctly allow
+		 * rename, cf bug #7909. But not on DENY ace entries, cf bug
+		 * #8442.
+		 */
+		if (aceprop.aceType == SMB_ACE4_ACCESS_ALLOWED_ACE_TYPE) {
+			aceprop.aceMask |= SMB_ACE4_SYNCHRONIZE;
+		}
+
+		if (is_dir && (aceprop.aceMask & SMB_ACE4_ADD_FILE)) {
+			aceprop.aceMask |= SMB_ACE4_DELETE_CHILD;
+		}
+
+		if(aceprop.aceFlags & ACE_OWNER) {
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_OWNER;
+		} else if(aceprop.aceFlags & ACE_GROUP) {
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_GROUP;
+		} else if(aceprop.aceFlags & ACE_EVERYONE) {
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_EVERYONE;
+		} else {
+			aceprop.flags	= 0;
+		}
+		if(smb_add_ace4(pacl, &aceprop) == NULL)
+			return NT_STATUS_NO_MEMORY;
+	}
+
+	*ppacl = pacl;
+	return NT_STATUS_OK;
+}
+
+/* call-back function processing the NT acl -> ZFS acl using NFSv4 conv. */
+static bool zfs_process_smbacl(vfs_handle_struct *handle, files_struct *fsp,
+			       struct SMB4ACL_T *smbacl)
+{
+	SMB_ACE4PROP_T hidden_ace;
+	if (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {
+		hidden_ace.flags = SMB_ACE4_ID_SPECIAL;
+		hidden_ace.who.id = SMB_ACE4_WHO_EVERYONE;
+		hidden_ace.aceType = SMB_ACE4_ACCESS_ALLOWED_ACE_TYPE;
+		hidden_ace.aceFlags = (SMB_ACE4_FILE_INHERIT_ACE|SMB_ACE4_DIRECTORY_INHERIT_ACE);
+		hidden_ace.aceMask = 0;
+		DEBUG(9, ("ixnas: setting empty everyone@ ace on dir  %s \n", fsp->fsp_name->base_name));	
+	} else {
+		hidden_ace.flags = SMB_ACE4_ID_SPECIAL;
+		hidden_ace.who.id = SMB_ACE4_WHO_EVERYONE;
+		hidden_ace.aceType = SMB_ACE4_ACCESS_ALLOWED_ACE_TYPE;
+		hidden_ace.aceFlags = 0;
+		hidden_ace.aceMask = 0;
+		DEBUG(9, ("ixnas: setting empty everyone@ ace on file  %s \n", fsp->fsp_name->base_name));	
+	}
+
+	smb_add_ace4(smbacl, &hidden_ace);
+
+	int naces = smb_get_naces(smbacl), i;
+	ace_t *acebuf;
+	struct SMB4ACE_T *smbace;
+	TALLOC_CTX	*mem_ctx;
+	bool have_special_id = false;
+
+	/* allocate the field of ZFS aces */
+	mem_ctx = talloc_tos();
+	acebuf = (ace_t *) talloc_size(mem_ctx, sizeof(ace_t)*naces);
+	if(acebuf == NULL) {
+		errno = ENOMEM;
+		return False;
+	}
+	/* handle all aces */
+	for(smbace = smb_first_ace4(smbacl), i = 0;
+			smbace!=NULL;
+			smbace = smb_next_ace4(smbace), i++) {
+		SMB_ACE4PROP_T *aceprop = smb_get_ace4(smbace);
+
+		acebuf[i].a_type        = aceprop->aceType;
+		acebuf[i].a_flags       = aceprop->aceFlags;
+		acebuf[i].a_access_mask = aceprop->aceMask;
+		/* SYNC on acls is a no-op on ZFS.
+		   See bug #7909. */
+		acebuf[i].a_access_mask &= ~SMB_ACE4_SYNCHRONIZE;
+		acebuf[i].a_who         = aceprop->who.id;
+		if(aceprop->flags & SMB_ACE4_ID_SPECIAL) {
+			switch(aceprop->who.special_id) {
+			case SMB_ACE4_WHO_EVERYONE:
+				acebuf[i].a_flags |= ACE_EVERYONE;
+				break;
+			case SMB_ACE4_WHO_OWNER:
+				acebuf[i].a_flags |= ACE_OWNER;
+				break;
+			case SMB_ACE4_WHO_GROUP:
+				acebuf[i].a_flags |= ACE_GROUP|ACE_IDENTIFIER_GROUP;
+				break;
+			default:
+				DEBUG(8, ("unsupported special_id %d\n", \
+					aceprop->who.special_id));
+				continue; /* don't add it !!! */
+			}
+			have_special_id = true;
+		}
+	}
+
+	if (!have_special_id
+	    && lp_parm_bool(fsp->conn->params->service, "ixnas",
+			    "denymissingspecial", false)) {
+		errno = EACCES;
+		return false;
+	}
+
+	SMB_ASSERT(i == naces);
+
+	/* store acl */
+	if(acl(fsp->fsp_name->base_name, ACE_SETACL, naces, acebuf)) {
+		if(errno == ENOSYS) {
+			DEBUG(9, ("acl(ACE_SETACL, %s): Operation is not "
+				  "supported on the filesystem where the file "
+				  "reside", fsp_str_dbg(fsp)));
+		} else {
+			DEBUG(9, ("acl(ACE_SETACL, %s): %s ", fsp_str_dbg(fsp),
+				  strerror(errno)));
+		}
+		return 0;
+	}
+
+	return True;
+}
+
+/* zfs_set_nt_acl()
+ * set the local file's acls obtaining it in NT form
+ * using the NFSv4 format conversion
+ */
+static NTSTATUS zfs_set_nt_acl(vfs_handle_struct *handle, files_struct *fsp,
+			   uint32_t security_info_sent,
+			   const struct security_descriptor *psd,
+			   struct ixnas_config_data *config)
+{
+        return smb_set_nt_acl_nfs4(handle, fsp, &config->nfs4_params, security_info_sent, psd,
+				   zfs_process_smbacl);
+}
+
+static NTSTATUS ixnas_fget_nt_acl(struct vfs_handle_struct *handle,
+				   struct files_struct *fsp,
+				   uint32_t security_info,
+				   TALLOC_CTX *mem_ctx,
+				   struct security_descriptor **ppdesc)
+{
+	struct SMB4ACL_T *pacl;
+	NTSTATUS status;
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->zfs_acl_enabled) {
+		TALLOC_FREE(frame);
+		return SMB_VFS_NEXT_FGET_NT_ACL(handle, fsp, security_info, mem_ctx, ppdesc);
+	}
+
+	status = zfs_get_nt_acl_common(handle->conn, frame,
+				       fsp->fsp_name, &pacl, config);
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(frame);
+		return status;
+	}
+
+	status = smb_fget_nt_acl_nfs4(fsp, &config->nfs4_params, security_info, mem_ctx,
+				      ppdesc, pacl);
+	TALLOC_FREE(frame);
+	return status;
+}
+
+static NTSTATUS ixnas_get_nt_acl(struct vfs_handle_struct *handle,
+				const struct smb_filename *smb_fname,
+				uint32_t security_info,
+				TALLOC_CTX *mem_ctx,
+				struct security_descriptor **ppdesc)
+{
+	struct SMB4ACL_T *pacl;
+	NTSTATUS status;
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->zfs_acl_enabled) {
+		TALLOC_FREE(frame);
+		return SMB_VFS_NEXT_GET_NT_ACL(handle, smb_fname, security_info, mem_ctx, ppdesc);
+	}
+
+	status = zfs_get_nt_acl_common(handle->conn, frame, smb_fname, &pacl, config);
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(frame);
+		return status;
+	}
+
+	status = smb_get_nt_acl_nfs4(handle->conn,
+					smb_fname,
+					&config->nfs4_params,
+					security_info,
+					mem_ctx,
+					ppdesc,
+					pacl);
+	TALLOC_FREE(frame);
+	return status;
+}
+
+static NTSTATUS ixnas_fset_nt_acl(vfs_handle_struct *handle,
+			 files_struct *fsp,
+			 uint32_t security_info_sent,
+			 const struct security_descriptor *psd)
+{
+	struct ixnas_config_data *config;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (!config->zfs_acl_enabled) {
+		return SMB_VFS_NEXT_FSET_NT_ACL(handle, fsp, security_info_sent, psd);
+	}
+
+	return zfs_set_nt_acl(handle, fsp, security_info_sent, psd, config);
+}
+
+/********************************************************************
+ Optimization. Load parameters on connect. This allows us to enable
+ and disable portions of the large vfs module on demand.
+********************************************************************/
+static int ixnas_connect(struct vfs_handle_struct *handle,
+			    const char *service, const char *user)
+{
+	struct ixnas_config_data *config;
+	int ret;
+
+	config = talloc_zero(handle->conn, struct ixnas_config_data);
+	if (!config) {
+		DEBUG(0, ("talloc_zero() failed\n"));
+		errno = ENOMEM;
+		return -1;
+	}
+
+	ret = SMB_VFS_NEXT_CONNECT(handle, service, user);
+	if (ret < 0) {
+		TALLOC_FREE(config);
+		return ret;
+	}
+
+	ret = smbacl4_get_vfs_params(handle->conn, &config->nfs4_params);
+	if (ret < 0) {
+		TALLOC_FREE(config);
+		return ret;
+	}
+
+	/* OS-X Compatibility */
+	config->posix_rename = lp_parm_bool(SNUM(handle->conn), "ixnas",
+				"posix_rename", false);
+
+	/* DOSMODE PARAMETERS */
+	config->dosmode_enabled = lp_parm_bool(SNUM(handle->conn), "ixnas",
+					"dosmode_enabled", true);
+
+	/* 
+	 * When DOS modes are mapped to file flags, make sure other alternate
+	 * mapping of DOS modes are disabled.
+	 */
+
+	if (config->dosmode_enabled) {
+		if ((lp_map_readonly(SNUM(handle->conn))) == MAP_READONLY_YES) {
+			DEBUG(5, ("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'map readonly'\n"));
+			lp_do_parameter(SNUM(handle->conn), "map readonly",
+					"no");
+		}
+
+		if (lp_map_archive(SNUM(handle->conn))) {
+			DEBUG(5, ("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'map archive'\n"));
+			lp_do_parameter(SNUM(handle->conn), "map archive",
+					"no");
+		}
+
+		if (lp_store_dos_attributes(SNUM(handle->conn))){
+			DEBUG(5, ("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'store dos attributes'\n"));
+			lp_do_parameter(SNUM(handle->conn), "store dos attributes",
+					"no");
+		}
+
+		/*
+		 * Check to see if we want to enable offline files support. This is
+		 * Optimization inspired by vfs_offline by Uri Simchoni. Improves dir
+		 * listing speed for Windows Explorer by making it so that thumbnails
+		 * aren't generated
+		 */
+		config->dosmode_remote_storage = lp_parm_bool(SNUM(handle->conn), "ixnas",
+						"dosmode_remote_storage", false);
+	}
+
+	/* ZFS ACL PARAMETERS */
+	config->zfs_acl_enabled = lp_parm_bool(SNUM(handle->conn), "ixnas",
+					"zfs_acl_enabled", true);
+
+	if (config->zfs_acl_enabled) {
+		config->zfs_acl_mapdaclprotected = lp_parm_bool(SNUM(handle->conn),
+						"ixnas","zfsacl_mapdaclprotected", true);	
+		
+		config->zfs_acl_denymissingspecial = lp_parm_bool(SNUM(handle->conn),
+						"ixnas","zfsacl_denymissingspecial",false);
+	}
+	
+	/* ZFS SPACE PARAMETERS */
+#if HAVE_LIBZFS
+	config->zfs_space_enabled = lp_parm_bool(SNUM(handle->conn), "ixnas",
+				   "zfs_space_enabled", false);
+#endif
+
+	SMB_VFS_HANDLE_SET_DATA(handle, config,
+				NULL, struct ixnas_config_data,
+				return -1);
+
+	return 0;
+}
+
+static struct vfs_fn_pointers ixnas_fns = {
+	.connect_fn = ixnas_connect,
+	.create_file_fn = ixnas_create_file,
+	.fs_capabilities_fn = ixnas_fs_capabilities,
+	/* dosmode_enabled */
+	.get_dos_attributes_fn = ixnas_get_dos_attributes,
+	.fget_dos_attributes_fn = ixnas_fget_dos_attributes,
+	.set_dos_attributes_fn = ixnas_set_dos_attributes,
+	.fset_dos_attributes_fn = ixnas_fset_dos_attributes,
+	/* zfs_acl_enabled = true */
+	.fget_nt_acl_fn = ixnas_fget_nt_acl,
+	.get_nt_acl_fn = ixnas_get_nt_acl,
+	.fset_nt_acl_fn = ixnas_fset_nt_acl,
+#if HAVE_LIBZFS
+	.disk_free_fn = ixnas_disk_free
+#endif
+};
+
+NTSTATUS vfs_ixnas_init(TALLOC_CTX *);
+NTSTATUS vfs_ixnas_init(TALLOC_CTX *ctx)
+{
+        return smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "ixnas",
+                                &ixnas_fns);
+}
diff --git a/source3/modules/vfs_winmsa.c b/source3/modules/vfs_winmsa.c
new file mode 100644
index 0000000..8387a64
--- /dev/null
+++ b/source3/modules/vfs_winmsa.c
@@ -0,0 +1,332 @@
+/*
+ *  *	Windows MoveSecurityAttributes
+ *   */
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "smbd/smbd.h"
+#include "nfs4_acls.h"
+
+#if HAVE_FREEBSD_SUNACL_H
+#include "sunacl.h"
+#endif
+
+#ifndef NAME_MAX
+#define NAME_MAX 255
+#endif
+
+#undef DBGC_CLASS
+#define DBGC_CLASS DBGC_VFS
+
+#define WINMSA_MODULE_NAME "winmsa"
+
+typedef struct winmsa_info {
+	int d_naces;
+	int f_naces;
+	ace_t *d_aces;
+	ace_t *f_aces;
+	uid_t uid;
+	gid_t gid;
+	char *path;
+} winmsa_info_t;
+
+
+static char *parent_dir(TALLOC_CTX *ctx, const char *name)
+{
+	const char *p = strrchr(name, '/');
+	if (p == NULL)
+		return NULL;
+
+	return  talloc_strndup(ctx, name, (p + 1) - name);
+}
+
+static void winmsa_dump_acl(const char *path, ace_t *aces, int naces)
+{
+	int i;
+
+	DEBUG(5, ("PATH=%s\n", path));
+	for (i = 0;i < naces;i++) {
+		ace_t *ace = &(aces[i]);
+		DEBUG(5, ("ACE: [%02d/%02d] who=%08x [%-10d] mask=%08x flags=%08x type=%08x\n",
+			i + 1, naces, ace->a_who, ace->a_who, ace->a_access_mask, ace->a_flags, ace->a_type));
+	}
+}
+
+static int winmsa_get_naces(const char *path)
+{
+	int naces;
+
+	if ((naces = acl(path, ACE_GETACLCNT, 0, NULL)) < 0) {
+		if(errno == ENOSYS) {
+			DEBUG(5, ("acl(ACE_GETACLCNT, %s): Operation is not "
+				"supported on the filesystem where the file reside\n", path));
+		} else {
+			DEBUG(5, ("acl(ACE_GETACLCNT, %s): %s ", path, strerror(errno)));
+		}
+		return -1;
+	}
+
+	return naces;
+}
+
+static int winmsa_get_acl(TALLOC_CTX *ctx, winmsa_info_t *info)
+{
+	int i;
+
+	if (info == NULL || info->path == NULL)
+		return -1;
+
+	if ((info->d_naces = winmsa_get_naces(info->path)) < 0)
+		return -1;
+
+	if ((info->d_aces = talloc_size(ctx, sizeof(ace_t) * info->d_naces)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	if ((acl(info->path, ACE_GETACL, info->d_naces, info->d_aces)) < 0) {
+		DEBUG(3, ("winmsa_get_acl(%s): %s ", info->path, strerror(errno)));
+		return -1;
+	}
+
+	for (i = 0;i < info->d_naces;i++) {
+		info->d_aces[i].a_flags |= ACE_INHERITED_ACE;
+	}
+	
+	return 0;
+}
+
+static int winmsa_file_acl(TALLOC_CTX *ctx, winmsa_info_t *info)	
+{
+	int i;
+
+	if (info == NULL || info->path == NULL)
+		return -1;
+
+	if ((info->f_naces = winmsa_get_naces(info->path)) < 0)
+		return -1;
+
+	if ((info->f_aces = talloc_size(ctx, sizeof(ace_t) * info->f_naces)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	if ((acl(info->path, ACE_GETACL, info->f_naces, info->f_aces)) < 0) {
+		DEBUG(3, ("winmsa_file_acl(%s): %s ", info->path, strerror(errno)));
+		return -1;
+	}
+
+	for (i = 0;i < info->f_naces;i++) {
+		info->f_aces[i].a_flags &= ~(
+			ACE_FILE_INHERIT_ACE|
+			ACE_DIRECTORY_INHERIT_ACE|
+			ACE_NO_PROPAGATE_INHERIT_ACE|
+			ACE_INHERIT_ONLY_ACE
+		);
+		
+		info->f_aces[i].a_flags |= ACE_INHERITED_ACE;
+	}
+
+	return 0;
+}
+
+static int winmsa_get_ownership(winmsa_info_t *info)
+{
+	SMB_STRUCT_STAT sbuf;
+
+	if (sys_lstat(info->path, &sbuf, false) < 0) {
+		DEBUG(3, ("winmsa_get_ownership: stat failed for %s\n", info->path));
+		return -1;
+	}
+
+	info->uid = sbuf.st_ex_uid;
+	info->gid = sbuf.st_ex_gid;
+
+	return 0;
+}
+
+/* this  routine must be called under a become_root context to operate with sufficent access */
+static int winmsa_set_acls(TALLOC_CTX *ctx, struct vfs_handle_struct *handle,
+						winmsa_info_t *info, const char *path)
+{
+	int ret;
+	DIR *dh;
+	struct dirent de;
+	struct dirent *result;
+	SMB_STRUCT_STAT sbuf;
+
+	if (sys_lstat(path, &sbuf, false) < 0) {
+		DEBUG(3, ("winmsa_set_acls: stat failed for %s\n", path));
+		return -1;
+	}
+
+	if (S_ISLNK(sbuf.st_ex_mode))
+		return 0;
+
+	if (!S_ISDIR(sbuf.st_ex_mode)) {
+		/* these calls require escalated privileges */
+		if (lp_parm_bool(handle->conn->params->service, "winmsa", "chown", True)){
+			if (chown(path, info->uid, info->gid) < 0)
+				DEBUG(3, ("winmsa_set_acls: chown failed for %s\n", path));
+		}
+
+		if (acl(path, ACE_SETACL, info->f_naces, info->f_aces) < 0)
+			DEBUG(3, ("winmsa_set_acls: acl failed for %s\n", path));
+		return 0;
+	}
+
+	if ((dh = opendir(path)) == NULL) {
+		DEBUG(3, ("winmsa_set_acls: opendir failed for %s\n", path));
+		return -1;
+	}
+
+	for (ret = readdir_r(dh, &de, &result); result != NULL && ret == 0; ret = readdir_r(dh, &de, &result)) {
+		char *rp, *buf;
+
+		if (strcmp(de.d_name, ".") == 0 ||
+			strcmp(de.d_name, "..") == 0) {
+			continue;
+		}
+
+		if ((rp = talloc_size(ctx, PATH_MAX)) == NULL) {
+			errno = ENOMEM;
+			closedir(dh);
+			return -1;
+		}
+
+		if (realpath(path, rp) == NULL) {
+			talloc_free(rp);
+			DEBUG(3, ("winmsa_set_acls: realpath failed for %s\n", path));
+			continue;
+		}
+
+		if ((buf = talloc_size(ctx, PATH_MAX)) == NULL) {
+			talloc_free(rp);
+			errno = ENOMEM;
+			closedir(dh);
+			return -1;
+		}
+
+		snprintf(buf, PATH_MAX, "%s/%s", rp, de.d_name);
+		talloc_free(rp);
+
+		winmsa_set_acls(ctx, handle, info, buf);
+		talloc_free(buf);
+	}
+
+	closedir(dh);
+
+	/* these calls may require escalated privileges */
+	if (lp_parm_bool(handle->conn->params->service, "winmsa", "chown", True)){
+ 		if (chown(path, info->uid, info->gid) < 0)
+			DEBUG(3, ("winmsa_set_acls: chown failed for %s\n", path));
+	}
+ 
+	if (acl(path, ACE_SETACL, info->d_naces, info->d_aces) < 0)
+		DEBUG(3, ("winmsa_set_acls: acl failed for %s\n", path));
+
+	return 0;
+}
+
+static int winmsa_rename(struct vfs_handle_struct *handle,
+						const struct smb_filename *smb_fname_src,
+						const struct smb_filename *smb_fname_dst)
+{
+
+	int result = -1;
+	winmsa_info_t *info;
+	char *parent, *p1, *p2, *dst;
+	TALLOC_CTX *ctx;
+
+
+	if (SMB_VFS_NEXT_RENAME(handle, smb_fname_src, smb_fname_dst) < 0) {
+		DEBUG(3, ("winmsa_rename: rename failed: %s\n", strerror(errno)));
+		result = -1;
+		goto out;
+	}
+
+	if ((ctx = talloc_new(NULL)) == NULL) {
+		DEBUG(3, ("winmsa_rename: talloc failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	p1 = parent_dir(ctx, smb_fname_src->base_name);
+	p2 = parent_dir(ctx, smb_fname_dst->base_name);
+
+	if (p1 != NULL && p2 != NULL && strcmp(p1, p2) == 0) {
+		DEBUG(5, ("winmsa_rename: source and destination parent directory is the same\n"));
+		result = 0;
+		goto out;
+	}
+
+	if ((parent = parent_dir(ctx, smb_fname_dst->base_name)) == NULL) {
+		result = 0;
+		goto out;
+	}
+
+	if ((info = talloc_size(ctx, sizeof(winmsa_info_t))) == NULL) {
+		DEBUG(3, ("winmsa_rename: talloc_size failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	info->path = talloc_size(ctx, PATH_MAX);
+	if (realpath(parent, info->path) == NULL) {
+		DEBUG(3, ("winmsa_rename: realpath failed for %s\n", parent));
+		result = -1;
+		goto out;
+	}
+
+	dst = talloc_size(ctx, PATH_MAX);
+	if (realpath(smb_fname_dst->base_name, dst) == NULL) {
+		DEBUG(3, ("winmsa_rename: realpath failed for %s\n", smb_fname_dst->base_name));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_get_acl(ctx, info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_get_acl failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_file_acl(ctx, info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_file_acl failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_get_ownership(info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_get_ownership failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	/* WinMSA theory of operation requires setting the new file to  clone the ACE and Ownership
+ * 	of the parent of destination directory. Field deployment showed ( see jrq-485 )
+ * 		that the effective user did not always have the UNIX rights to accomplish this. 
+ * 			We become root here for the minimal necessary time due to multiple returns in
+ * 				winmsa_set_acls and goto's in this routine. */
+	become_root(); 
+	if ((result = winmsa_set_acls(ctx, handle, info, dst)) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_set_acls failed\n"));
+		result = -1;
+	}
+	unbecome_root(); 
+
+out:
+	TALLOC_FREE(ctx);
+	return result;
+}
+
+static struct vfs_fn_pointers winmsa_fns = {
+	.rename_fn = winmsa_rename,
+};
+
+NTSTATUS vfs_winmsa_init(TALLOC_CTX *);
+NTSTATUS vfs_winmsa_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "winmsa",
+				&winmsa_fns);
+}
diff --git a/source3/modules/vfs_zfs_space.c b/source3/modules/vfs_zfs_space.c
new file mode 100644
index 0000000..32b0b19
--- /dev/null
+++ b/source3/modules/vfs_zfs_space.c
@@ -0,0 +1,68 @@
+/*-
+ * Copyright 2015 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "lib/util/tevent_ntstatus.h"
+
+#include "modules/zfs_disk_free.h"
+
+
+static uint64_t vfs_zfs_space_disk_free(vfs_handle_struct *handle, const struct smb_filename *smb_fname,
+    uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	uint64_t res;
+	char rp[PATH_MAX] = { 0 };
+
+	if (realpath(smb_fname->base_name, rp) == NULL)
+		return (-1);
+
+	DEBUG(9, ("realpath = %s\n", rp));
+
+	res = smb_zfs_disk_free(rp, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		res = SMB_VFS_NEXT_DISK_FREE(handle, smb_fname, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		return (res);
+
+	DEBUG(9, ("*bsize = %" PRIu64 "\n", *bsize));
+	DEBUG(9, ("*dfree = %" PRIu64 "\n", *dfree));
+	DEBUG(9, ("*dsize = %" PRIu64 "\n", *dsize));
+
+	return (res);
+}
+
+static struct vfs_fn_pointers vfs_zfs_space_fns = {
+	.disk_free_fn = vfs_zfs_space_disk_free
+};
+
+NTSTATUS vfs_zfs_space_init(TALLOC_CTX *);
+NTSTATUS vfs_zfs_space_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION,
+		"zfs_space", &vfs_zfs_space_fns);
+}
diff --git a/source3/modules/zfs_disk_free.c b/source3/modules/zfs_disk_free.c
new file mode 100644
index 0000000..363f26d
--- /dev/null
+++ b/source3/modules/zfs_disk_free.c
@@ -0,0 +1,76 @@
+/*-
+ * Copyright 2015 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define NEED_SOLARIS_BOOLEAN
+
+#include <libzfs.h>
+
+#include "modules/zfs_disk_free.h"
+
+
+uint64_t
+smb_zfs_disk_free(char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	size_t blocksize = 1024;
+	libzfs_handle_t *libzfsp;
+	zfs_handle_t *zfsp;
+	uint64_t available, usedbysnapshots, usedbydataset,
+		usedbychildren, usedbyrefreservation, real_used, total;
+
+	if (path == NULL)
+		return (-1);
+
+	if ((libzfsp = libzfs_init()) == NULL)
+		return (-1);
+
+	libzfs_print_on_error(libzfsp, B_TRUE);
+
+	zfsp = zfs_path_to_zhandle(libzfsp, path,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+	if (zfsp == NULL)
+		return (-1);
+
+	available = zfs_prop_get_int(zfsp, ZFS_PROP_AVAILABLE);
+	usedbysnapshots = zfs_prop_get_int(zfsp, ZFS_PROP_USEDSNAP);
+	usedbydataset = zfs_prop_get_int(zfsp, ZFS_PROP_USEDDS);
+	usedbychildren = zfs_prop_get_int(zfsp, ZFS_PROP_USEDCHILD);
+	usedbyrefreservation = zfs_prop_get_int(zfsp, ZFS_PROP_USEDREFRESERV);
+
+	zfs_close(zfsp);
+	libzfs_fini(libzfsp);
+
+	real_used = usedbysnapshots + usedbydataset + usedbychildren;
+
+	total = (real_used + available) / blocksize;
+	available /= blocksize;
+
+	*bsize = blocksize;
+	*dfree = available;
+	*dsize = total;
+
+	return (*dfree);
+}
diff --git a/source3/modules/zfs_disk_free.h b/source3/modules/zfs_disk_free.h
new file mode 100644
index 0000000..7f47ff5
--- /dev/null
+++ b/source3/modules/zfs_disk_free.h
@@ -0,0 +1,33 @@
+/*-
+ * Copyright 2015 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef	__ZFS_DISK_FREE_H
+#define	__ZFS_DISK_FREE_H
+
+uint64_t smb_zfs_disk_free(char *path, uint64_t *bsize, uint64_t *dfree, uint64_t *dsize);
+
+#endif	/* !__ZFS_DISK_FREE_H */
